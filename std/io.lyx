// std/io.lyx
// Einfache I/O-Wrapper um vorhandene builtins (print_str, print_int, exit)

pub fn print(s: pchar): void {
  print_str(s);
}

pub fn println(s: pchar): void {
  print_str(s);
  print_str("\n");
}

// Überladene Varianten für println
pub fn println(x: int64): void {
  print_int(x);
  print_str("\n");
}

pub fn println(x: f64): void {
  print_float(x);
  print_str("\n");
}

pub fn println(b: bool): void {
  if (b) { print_str("true"); } else { print_str("false"); }
  print_str("\n");
}

pub fn print_intln(x: int64): void {
  print_int(x);
  print_str("\n");
}

import std.string;

// float_to_str: einfache Konvertierung f64 -> pchar mit fester Präzision
pub fn float_to_str(val: f64, prec: int64): pchar {
  var neg: bool := False;
  var v: f64 := val;
  if (v < 0.0) then begin neg := True; v := -v; end;
  var ip: int64 := trunc(v);
  var frac: f64 := v - ip;
  var scale: int64 := 1;
  var i: int64 := 0;
  while (i < prec) do begin scale := scale * 10; i := i + 1; end;
  var frac_scaled: int64 := round(frac * scale);

  var s_ip: pchar := int_to_str(ip);
  var s_frac: pchar := int_to_str(frac_scaled);

  // buffers
  var buf1: pchar := "                                        "; // 40 chars
  var buf2: pchar := "                                        ";

  // buf1 = s_ip + "."
  str_concat(buf1, s_ip, ".");
  // buf2 = buf1 + s_frac
  str_concat(buf2, buf1, s_frac);
  if (neg) then begin
    str_concat(buf1, "-", buf2);
    return buf1;
  end;
  return buf2;
}

// Core printf: unterstützt bis zu 4 bereits-formatierte pchar-Argumente
pub func printf_core(fmt: pchar, a1: pchar, a2: pchar, a3: pchar, a4: pchar): int64 {
  var i: int64 := 0;
  var n: int64 := str_length(fmt);
  var printed: int64 := 0;
  var chbuf: pchar := " ";
  var argIndex: int64 := 1; // next argument to consume (1..4)
  while (i < n) do
  begin
    var c: int64 := str_char_at(fmt, i);
    if (c = 37) then // '%'
    begin
      // next char
      i := i + 1;
      if (i >= n) then Break;
      var spec: int64 := str_char_at(fmt, i);
      if (spec = 37) then // '%%' -> '%'
      begin
        str_set_char(chbuf, 0, 37);
        print_str(chbuf);
        printed := printed + 1;
      end
      else if (spec = 115) // 's'
      begin
              // select argument by index
        var selIdx: int64 := argIndex;
        var arg: pchar := "";
        if selIdx = 1 then arg := a1
        else if selIdx = 2 then arg := a2
        else if selIdx = 3 then arg := a3
        else if selIdx = 4 then arg := a4
        else arg := "";
        // increment argIndex for next placeholder
        argIndex := argIndex + 1;
        if (arg <> "") then begin print_str(arg); printed := printed + str_length(arg); end;
      end
      else if (spec = 100) // 'd'
      begin
        var arg: pchar := a1; if (arg = "") then arg := a2; if (arg = "") then arg := a3; if (arg = "") then arg := a4;
        if (arg <> "") then begin print_str(arg); printed := printed + str_length(arg); end;
      end
      else if (spec = 102) // 'f'
      begin
        var arg: pchar := a1; if (arg = "") then arg := a2; if (arg = "") then arg := a3; if (arg = "") then arg := a4;
        if (arg <> "") then begin print_str(arg); printed := printed + str_length(arg); end;
      end
      else
      begin
        // unknown specifier: print as is (both % and char)
        str_set_char(chbuf, 0, 37);
        print_str(chbuf);
        str_set_char(chbuf, 0, spec);
        print_str(chbuf);
        printed := printed + 2;
      end;
    end
    else
    begin
      str_set_char(chbuf, 0, c);
      print_str(chbuf);
      printed := printed + 1;
    end;
    i := i + 1;
  end;
  return printed;
}

// Convenience overloads: automatische Konversion für 0..2 Argumente (pragmatisch), generisch für 3..4
pub fn printf(fmt: pchar): int64 {
  return printf_core(fmt, "", "", "", "");
}

pub fn printf(fmt: pchar, s1: pchar): int64 {
  return printf_core(fmt, s1, "", "", "");
}

pub fn printf(fmt: pchar, x: int64): int64 {
  var a: pchar := int_to_str(x);
  return printf_core(fmt, a, "", "", "");
}

pub fn printf(fmt: pchar, f: f64): int64 {
  var a: pchar := float_to_str(f, 6);
  return printf_core(fmt, a, "", "", "");
}

pub fn printf(fmt: pchar, s: pchar, x: int64): int64 {
  var a1: pchar := s;
  var a2: pchar := int_to_str(x);
  return printf_core(fmt, a1, a2, "", "");
}

pub fn printf(fmt: pchar, s: pchar, f: f64): int64 {
  var a1: pchar := s;
  var a2: pchar := float_to_str(f, 6);
  return printf_core(fmt, a1, a2, "", "");
}

pub fn printf(fmt: pchar, x: int64, y: int64): int64 {
  var a1: pchar := int_to_str(x);
  var a2: pchar := int_to_str(y);
  return printf_core(fmt, a1, a2, "", "");
}

pub fn printf(fmt: pchar, s1: pchar, s2: pchar): int64 {
  return printf_core(fmt, s1, s2, "", "");
}

// Generic 3-arg wrapper (konvertiert automatisch int64/f64/pchar gemischt)
pub fn printf(fmt: pchar, a: pchar, b: pchar, c: pchar): int64 {
  return printf_core(fmt, a, b, c, "");
}

pub fn printf(fmt: pchar, a: pchar, b: pchar, c: pchar, d: pchar): int64 {
  return printf_core(fmt, a, b, c, d);
}

pub fn exit_proc(code: int64): void {
  exit(code);
}
