// std/geo.lyx
// Geolocation utilities: parsing, formatting, validation
// All coordinates stored as microdegrees (int64: degrees * 1e6) for precision

import std.string;

// ============================================================================
// Parsing: String -> Microdegrees
// ============================================================================

pub fn parse_lat(s: pchar): int64 {
  return parse_coord(s);
}

pub fn parse_lon(s: pchar): int64 {
  return parse_coord(s);
}

// Parse decimal degrees (ddd.dddd) to microdegrees
fn parse_coord(s: pchar): int64 {
  var i: int64 := 0;
  var sign: int64 := 1;
  var first_char: int64 := str_char_at(s, 0);
  if (first_char == 45) { // '-'
    sign := -1;
    i := 1;
  }
  var whole: int64 := 0;
  var ch: int64 := str_char_at(s, i);
  while (ch >= 48 && ch <= 57) { // '0' to '9'
    whole := whole * 10 + (ch - 48);
    i := i + 1;
    ch := str_char_at(s, i);
  }
  var frac: int64 := 0;
  var frac_len: int64 := 0;
  if (ch == 46) { // '.'
    i := i + 1;
    ch := str_char_at(s, i);
    while (ch >= 48 && ch <= 57 && frac_len < 6) {
      frac := frac * 10 + (ch - 48);
      frac_len := frac_len + 1;
      i := i + 1;
      ch := str_char_at(s, i);
    }
    // skip remaining fractional digits
    while (ch >= 48 && ch <= 57) {
      i := i + 1;
      ch := str_char_at(s, i);
    }
  }
  // scale frac to 6 digits
  while (frac_len < 6) {
    frac := frac * 10;
    frac_len := frac_len + 1;
  }
  var result: int64 := whole * 1000000 + frac;
  return sign * result;
}

// ============================================================================
// Formatting: Microdegrees -> String
// ============================================================================

pub fn format_decimal(coord: int64): pchar {
  var sign: int64 := 1;
  if (coord < 0) {
    sign := -1;
    coord := -coord;
  }
  var deg: int64 := coord / 1000000;
  var frac: int64 := coord % 1000000;
  var buf: pchar := "                               ";
  var pos: int64 := 0;
  if (sign < 0) {
    str_set_char(buf, 0, 45);
    pos := 1;
  }
  var deg_str: pchar := int_to_str(deg);
  var i: int64 := 0;
  var deg_len: int64 := str_length(deg_str);
  while (i < deg_len) {
    str_set_char(buf, pos + i, str_char_at(deg_str, i));
    i := i + 1;
  }
  pos := pos + deg_len;
  str_set_char(buf, pos, 46); // '.'
  pos := pos + 1;
  // Pad fraction to 6 digits
  if (frac < 100000) {
    str_set_char(buf, pos, 48);
    pos := pos + 1;
  }
  if (frac < 10000) {
    str_set_char(buf, pos, 48);
    pos := pos + 1;
  }
  if (frac < 1000) {
    str_set_char(buf, pos, 48);
    pos := pos + 1;
  }
  if (frac < 100) {
    str_set_char(buf, pos, 48);
    pos := pos + 1;
  }
  if (frac < 10) {
    str_set_char(buf, pos, 48);
    pos := pos + 1;
  }
  var frac_str: pchar := int_to_str(frac);
  i := 0;
  var frac_len: int64 := str_length(frac_str);
  while (i < frac_len) {
    str_set_char(buf, pos + i, str_char_at(frac_str, i));
    i := i + 1;
  }
  pos := pos + frac_len;
  str_set_char(buf, pos, 0);
  return buf;
}

// ============================================================================
// Validation
// ============================================================================

pub fn is_valid_lat(lat: int64): bool {
  // Valid: -90.0 to +90.0 degrees (-90000000 to 90000000 microdegrees)
  return (lat >= -90000000) && (lat <= 90000000);
}

pub fn is_valid_lon(lon: int64): bool {
  // Valid: -180.0 to +180.0 degrees (-180000000 to 180000000 microdegrees)
  return (lon >= -180000000) && (lon <= 180000000);
}

// ============================================================================
// Simple Distance (Equirectangular Approximation)
// ============================================================================

// Earth radius in meters (approximately)
con EARTH_RADIUS_METERS: int64 := 6371000;

// Calculate approximate distance in meters
pub fn distance_m(lat1: int64, lon1: int64, lat2: int64, lon2: int64): int64 {
  var dlon: int64 := lon2 - lon1;
  var dlat: int64 := lat2 - lat1;
  
  // Simple approximation: convert microdegrees to meters
  // 1 degree â‰ˆ 111.32 km
  var x_m: int64 := (dlon * 111319) / 1000; // meters (approx)
  var y_m: int64 := (dlat * 111319) / 1000; // meters (approx)
  
  // Handle negative values for squaring
  if (x_m < 0) {
    x_m := -x_m;
  }
  if (y_m < 0) {
    y_m := -y_m;
  }
  
  // Pythagorean distance approximation
  if (x_m > y_m) {
    return x_m + (y_m / 2);
  } else {
    return y_m + (x_m / 2);
  }
}

// Distance in kilometers
pub fn distance_km(lat1: int64, lon1: int64, lat2: int64, lon2: int64): int64 {
  return distance_m(lat1, lon1, lat2, lon2) / 1000;
}

// ============================================================================
// Midpoint Calculation
// ============================================================================

pub fn midpoint_lat(lat1: int64, lat2: int64): int64 {
  return (lat1 + lat2) / 2;
}

pub fn midpoint_lon(lon1: int64, lon2: int64): int64 {
  var diff: int64 := lon2 - lon1;
  if (diff > 180000000) {
    diff := diff - 360000000;
  }
  if (diff < -180000000) {
    diff := diff + 360000000;
  }
  var mid: int64 := lon1 + (diff / 2);
  if (mid > 180000000) {
    mid := mid - 360000000;
  }
  if (mid < -180000000) {
    mid := mid + 360000000;
  }
  return mid;
}

// End of std/geo.lyx
