// std/string.lyx
// Standard String Library für Lyx - Mit Builtins
// Arbeitet mit pchar (null-terminated strings)

// ============================================================================
// CORE FUNCTIONS (using builtins - no wrapper needed, builtins sind bereits verfügbar)
// StrLength, str_compare, StrCharAt, StrSetChar, str_copy_builtin
// Diese sind bereits als Builtins registriert und können direkt verwendet werden
// ============================================================================

// ============================================================================  
// COMPATIBILITY (alte Namen für Rückwärtskompatibilität)
// ============================================================================

pub fn strcmp(a: pchar, b: pchar): int64 {
  return str_compare(a, b);
}

pub fn strcpy(dest: pchar, src: pchar): pchar {
  str_copy_builtin(dest, src);
  return dest;
}

// Wrapper für StrCopy mit return value
pub fn StrCopy(dest: pchar, src: pchar): pchar {
  str_copy_builtin(dest, src);
  return dest;
}

// ============================================================================
// UTILITY FUNCTIONS (built on top of builtins)
// ============================================================================

pub fn StrFind(haystack: pchar, needle: pchar): int64 {
  // Findet erste Occurrence von needle in haystack
  // Return: Index oder -1 wenn nicht gefunden
  var hay_len: int64 := StrLength(haystack);
  var needle_len: int64 := StrLength(needle);
  
  if (needle_len == 0) { return 0; }  // empty needle matches at start
  if (needle_len > hay_len) { return -1; }
  
  var i: int64 := 0;
  while (i <= hay_len - needle_len) {
    var match: bool := true;
    var j: int64 := 0;
    
    while (j < needle_len && match) {
      if (StrCharAt(haystack, i + j) != StrCharAt(needle, j)) {
        match := false;
      }
      j := j + 1;
    }
    
    if (match) { return i; }
    i := i + 1;
  }
  return -1;
}

pub fn StrSafeCharAt(s: pchar, index: int64): int64 {
  // Sicherer Character-Zugriff mit Bounds-Check
  // Return: Character-Code oder -1 wenn Index außerhalb
  var len: int64 := StrLength(s);
  if (index < 0 || index >= len) { return -1; }
  return StrCharAt(s, index);
}

// ============================================================================
// CASE CONVERSION
// ============================================================================

pub fn CharToLower(c: int64): int64 {
  // Konvertiert einzelnes Character zu lowercase
  if (c >= 65 && c <= 90) {  // 'A' bis 'Z'
    return c + 32;  // zu 'a' bis 'z'  
  }
  return c;
}

pub fn CharToUpper(c: int64): int64 {
  // Konvertiert einzelnes Character zu uppercase
  if (c >= 97 && c <= 122) {  // 'a' bis 'z'
    return c - 32;  // zu 'A' bis 'Z'
  }
  return c;
}

pub fn StrToLower(dest: pchar, src: pchar): pchar {
  // Konvertiert String zu lowercase (dest kann == src sein)
  var len: int64 := StrLength(src);
  var i: int64 := 0;
  while (i < len) {
    StrSetChar(dest, i, CharToLower(StrCharAt(src, i)));
    i := i + 1;
  }
  StrSetChar(dest, len, 0);  // null-terminator
  return dest;
}

pub fn StrToUpper(dest: pchar, src: pchar): pchar {
  // Konvertiert String zu uppercase (dest kann == src sein)
  var len: int64 := StrLength(src);
  var i: int64 := 0;
  while (i < len) {
    StrSetChar(dest, i, CharToUpper(StrCharAt(src, i)));
    i := i + 1;
  }
  StrSetChar(dest, len, 0);  // null-terminator
  return dest;
}

// ============================================================================
// BOOLEAN STRING TESTS
// ============================================================================

pub fn StrEquals(s1: pchar, s2: pchar): bool {
  // Prüft String-Gleichheit (convenience function)
  return str_compare(s1, s2) == 0;
}

pub fn StrStartsWith(s: pchar, prefix: pchar): bool {
  // Prüft ob String mit Prefix beginnt
  var prefix_len: int64 := StrLength(prefix);
  var s_len: int64 := StrLength(s);
  
  if (prefix_len > s_len) { return false; }
  
  var i: int64 := 0;
  while (i < prefix_len) {
    if (StrCharAt(s, i) != StrCharAt(prefix, i)) { return false; }
    i := i + 1;
  }
  return true;
}

pub fn StrEndsWith(s: pchar, suffix: pchar): bool {
  // Prüft ob String mit Suffix endet
  var suffix_len: int64 := StrLength(suffix);
  var s_len: int64 := StrLength(s);
  
  if (suffix_len > s_len) { return false; }
  
  var start: int64 := s_len - suffix_len;
  var i: int64 := 0;
  while (i < suffix_len) {
    if (StrCharAt(s, start + i) != StrCharAt(suffix, i)) { return false; }
    i := i + 1;
  }
  return true;
}

pub fn IsWhitespace(c: int64): bool {
  // Prüft ob Character Whitespace ist
  return (c == 32 || c == 9 || c == 10 || c == 13);  // ' ', '\t', '\n', '\r'
}

// ============================================================================
// STRING MODIFICATION FUNCTIONS
// ============================================================================

pub fn StrConcat(dest: pchar, s1: pchar, s2: pchar): pchar {
  // Konkateniert s1 + s2 nach dest
  // dest muss genügend Platz haben (StrLength(s1) + StrLength(s2) + 1)
  str_copy_builtin(dest, s1);
  var s1_len: int64 := StrLength(s1);
  var s2_len: int64 := StrLength(s2);
  
  var i: int64 := 0;
  while (i < s2_len) {
    StrSetChar(dest, s1_len + i, StrCharAt(s2, i));
    i := i + 1;
  }
  StrSetChar(dest, s1_len + s2_len, 0);  // null-terminator
  return dest;
}

pub fn StrReverse(s: pchar): pchar {
  // Kehrt String in-place um
  var len: int64 := StrLength(s);
  var i: int64 := 0;
  var j: int64 := len - 1;
  
  while (i < j) {
    var temp: int64 := StrCharAt(s, i);
    StrSetChar(s, i, StrCharAt(s, j));
    StrSetChar(s, j, temp);
    i := i + 1;
    j := j - 1;
  }
  return s;
}

pub fn StrTrimWhitespace(dest: pchar, src: pchar): pchar {
  // Entfernt führende und nachfolgende Whitespace
  var len: int64 := StrLength(src);
  
  // Führende Whitespace finden
  var start: int64 := 0;
  while (start < len && IsWhitespace(StrCharAt(src, start))) {
    start := start + 1;
  }
  
  // Nachfolgende Whitespace finden
  var end: int64 := len - 1;
  while (end >= start && IsWhitespace(StrCharAt(src, end))) {
    end := end - 1;
  }
  
  // String kopieren
  var i: int64 := 0;
  while (start <= end) {
    StrSetChar(dest, i, StrCharAt(src, start));
    start := start + 1;
    i := i + 1;
  }
  StrSetChar(dest, i, 0);  // null-terminator
  
  return dest;
}