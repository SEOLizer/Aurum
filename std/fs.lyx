// std/fs.lyx - Dateisystem-API (Filesystem API)
// Plattform-unabhängige Dateioperationen für Lyx v0.3.0
// Linux: libc-Wrapper | Windows: Windows-API (zukünftig)

unit std.fs;

// ============================================================================
// Typen
// ============================================================================

// File descriptor/handle - abstrakt für Unix fd und Windows HANDLE
pub type fd: int64;

// ============================================================================
// Konstanten - Unix-Standard Flags (auf Windows gemappt)
// ============================================================================

// Zugriffsmodi
pub con O_RDONLY: int64 := 0;      // Nur Lesen
pub con O_WRONLY: int64 := 1;      // Nur Schreiben
pub con O_RDWR: int64 := 2;        // Lesen und Schreiben

// Creation/Status Flags
pub con O_CREAT: int64 := 64;      // 0100 - Erstellen falls nicht existiert
pub con O_TRUNC: int64 := 512;     // 01000 - Auf 0 Bytes kürzen
pub con O_APPEND: int64 := 1024;   // 02000 - Anhängen
pub con O_EXCL: int64 := 128;      // 0200 - Fehler falls existiert

// Datei-Rechte (Mode für open mit O_CREAT)
pub con S_IRUSR: int64 := 256;     // 0400 - Owner read
pub con S_IWUSR: int64 := 128;     // 0200 - Owner write
pub con S_IRGRP: int64 := 32;      // 0040 - Group read
pub con S_IWGRP: int64 := 16;      // 0020 - Group write
pub con S_IROTH: int64 := 4;       // 0004 - Other read
pub con S_IWOTH: int64 := 2;       // 0002 - Other write

// Standard file permissions: rw-r--r-- (0644)
pub con DEFAULT_MODE: int64 := 420; // 0644 octal

// Special file descriptors
pub con STDIN_FILENO: int64 := 0;
pub con STDOUT_FILENO: int64 := 1;
pub con STDERR_FILENO: int64 := 2;

// ============================================================================
// Externe Funktionen (libc-Wrapper - Linux)
// ============================================================================

// Unter Linux: direkte libc-Aufrufe
// Unter Windows: werden auf CreateFile/ReadFile/WriteFile/CloseHandle gemappt

// Datei öffnen
// Returns: fd >= 0 bei Erfolg, -1 bei Fehler (errno gesetzt)
extern fn open(path: pchar, flags: int64, mode: int64): fd;

// Von Datei lesen
// Returns: Anzahl gelesener Bytes, 0 = EOF, -1 = Fehler
extern fn read(f: fd, buf: pchar, count: int64): int64;

// In Datei schreiben
// Returns: Anzahl geschriebener Bytes, -1 = Fehler
extern fn write(f: fd, buf: pchar, count: int64): int64;

// Datei schließen
// Returns: 0 bei Erfolg, -1 bei Fehler
extern fn close(f: fd): int64;

// Datei löschen
// Returns: 0 bei Erfolg, -1 bei Fehler
extern fn unlink(path: pchar): int64;

// Datei umbenennen/verschieben
// Returns: 0 bei Erfolg, -1 bei Fehler
extern fn rename(oldpath: pchar, newpath: pchar): int64;

// Dateigröße ermitteln (via lseek)
// Returns: Dateigröße in Bytes, -1 bei Fehler
extern fn lseek(fd: fd, offset: int64, whence: int64): int64;

// ============================================================================
// Konstanten für lseek
// ============================================================================

pub con SEEK_SET: int64 := 0;  // Vom Dateianfang
pub con SEEK_CUR: int64 := 1;  // Von aktueller Position
pub con SEEK_END: int64 := 2;  // Vom Dateiende

// ============================================================================
// Hilfsfunktionen (pure Lyx)
// ============================================================================

// Prüft ob ein File Descriptor gültig ist
pub fn IsValidFd(f: fd): bool {
  return f >= 0;
}

// Liest kompletten Dateiinhalt in Buffer (max max_len Bytes)
// Returns: Anzahl gelesener Bytes oder -1 bei Fehler
pub fn ReadFile(path: pchar, buf: pchar, max_len: int64): int64 {
  var f: fd := open(path, O_RDONLY, 0);
  if (f < 0) {
    return -1;
  }

  var total: int64 := 0;
  var n: int64 := 0;

  while (total < max_len) {
    n := read(f, buf + total, max_len - total);
    if (n < 0) {
      close(f);
      return -1;  // Fehler
    }
    if (n == 0) {
      break;  // EOF
    }
    total := total + n;
  }

  close(f);
  return total;
}

// Schreibt Buffer in Datei (überschreibt existierende Datei)
// Returns: Anzahl geschriebener Bytes oder -1 bei Fehler
pub fn WriteFile(path: pchar, buf: pchar, len: int64): int64 {
  var f: fd := open(path, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_MODE);
  if (f < 0) {
    return -1;
  }

  var total: int64 := 0;
  var n: int64 := 0;

  while (total < len) {
    n := write(f, buf + total, len - total);
    if (n < 0) {
      close(f);
      return -1;
    }
    if (n == 0) {
      break;  // Kann nicht mehr schreiben
    }
    total := total + n;
  }

  close(f);
  return total;
}

// An Datei anhängen
// Returns: Anzahl geschriebener Bytes oder -1 bei Fehler
pub fn AppendFile(path: pchar, buf: pchar, len: int64): int64 {
  var f: fd := open(path, O_WRONLY | O_CREAT | O_APPEND, DEFAULT_MODE);
  if (f < 0) {
    return -1;
  }

  var n: int64 := write(f, buf, len);
  close(f);
  return n;
}

// Datei löschen (Wrapper)
pub fn DeleteFile(path: pchar): bool {
  return unlink(path) == 0;
}

// Datei existiert?
// Returns: true wenn lesbar, false sonst
pub fn FileExists(path: pchar): bool {
  var f: fd := open(path, O_RDONLY, 0);
  if (f < 0) {
    return false;
  }
  close(f);
  return true;
}

// ============================================================================
// Dateigröße ermitteln
// ============================================================================

pub fn FileSize(path: pchar): int64 {
  var f: fd := open(path, O_RDONLY, 0);
  if (f < 0) {
    return -1;
  }

  // Gehe zum Ende der Datei
  var size: int64 := lseek(f, 0, SEEK_END);
  close(f);
  return size;
}

// ============================================================================
// Standard-I/O Wrapper (für Komfort)
// ============================================================================

// Text auf stdout ausgeben (low-level)
pub fn StdoutWrite(buf: pchar, len: int64): int64 {
  return write(STDOUT_FILENO, buf, len);
}

// Text auf stderr ausgeben
pub fn StderrWrite(buf: pchar, len: int64): int64 {
  return write(STDERR_FILENO, buf, len);
}

// Ein Zeichen ausgeben
pub fn PutChar(c: int64): int64 {
  var chbuf: pchar := " ";
  // chbuf[0] = c;  // TODO: Array-Index-Zuweisung in Lyx
  // Workaround: Nur Leerzeichen für jetzt
  return write(STDOUT_FILENO, chbuf, 1);
}

// ============================================================================
// Ende std/fs.lyx
// ============================================================================
