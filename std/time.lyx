// std/time.lyx
// Vereinfachte Zeitfunktionen mit korrekter Lyx-Syntax

// Tage seit 1970-01-01 (Unix epoch) berechnen
pub fn DaysFromCivil(year: int64, month: int64, day: int64): int64 {
  var y: int64 := year;
  var m: int64 := month;
  var d: int64 := day;

  if (m <= 2) {
    y := y - 1;
    m := m + 12;
  }

  var era: int64 := y / 400;
  if (y < 0) {
    if ((y % 400) != 0) {
      era := era - 1;
    }
  }

  var yoe: int64 := y - era * 400;
  var doy: int64 := (153 * (m - 3) + 2) / 5 + d - 1;
  var doe: int64 := yoe * 365 + yoe / 4 - yoe / 100 + doy;

  return era * 146097 + doe - 719468;
}

// Jahr aus Tagen seit Epoch extrahieren
pub fn CivilYearFromDays(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  return yoe + era * 400;
}

// Monat aus Tagen seit Epoch extrahieren
pub fn CivilMonthFromDays(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  var y: int64 := yoe + era * 400;
  var doy: int64 := doe - (365*yoe + yoe/4 - yoe/100);
  var mp: int64 := (5 * doy + 2) / 153;
  var month: int64 := mp + 3;
  if (mp >= 10) {
    month := month - 12;
  }
  return month;
}

// Tag aus Tagen seit Epoch extrahieren
pub fn CivilDayFromDays(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  var y: int64 := yoe + era * 400;
  var doy: int64 := doe - (365*yoe + yoe/4 - yoe/100);
  var mp: int64 := (5 * doy + 2) / 153;
  return doy - (153*mp+2)/5 + 1;
}

// Schaltjahr prüfen
pub fn IsLeapYear(y: int64): bool {
  if ((y % 4) != 0) {
    return false;
  }
  if ((y % 100) != 0) {
    return true;
  }
  if ((y % 400) == 0) {
    return true;
  }
  return false;
}

// --- Native Zeittypen APIs ---

pub fn DateFromYmd(year: int64, month: int64, day: int64): date {
  var d: int64 := DaysFromCivil(year, month, day);
  return d;
}

pub fn YearFromDate(d: date): int64 {
  return CivilYearFromDays(d);
}

pub fn MonthFromDate(d: date): int64 {
  return CivilMonthFromDays(d);
}

pub fn DayFromDate(d: date): int64 {
  return CivilDayFromDays(d);
}

pub fn TimeFromHms(hour: int64, minute: int64, second: int64): time {
  return hour * 3600 + minute * 60 + second;
}

pub fn HourFromTime(t: time): int64 {
  return t / 3600;
}

pub fn MinuteFromTime(t: time): int64 {
  return (t % 3600) / 60;
}

pub fn SecondFromTime(t: time): int64 {
  return t % 60;
}

pub fn DatetimeFromUnixSeconds(sec: int64): datetime {
  return sec;
}

pub fn DatetimeToUnixSeconds(dt: datetime): int64 {
  return dt;
}

pub fn TimestampFromUnixSeconds(sec: int64): timestamp {
  return sec * 1000000;
}

pub fn UnixSecondsFromTimestamp(ts: timestamp): int64 {
  return ts / 1000000;
}

// --- Aktuelle Systemzeit ---

// Externe Builtins für Systemzeit (werden vom Compiler bereitgestellt)
extern fn now_unix(): int64;
extern fn now_unix_ms(): int64;

// Aktuelle Zeit als datetime (Sekunden seit Epoch)
pub fn now(): datetime {
  return now_unix();
}

// Aktuelle Zeit als timestamp (Mikrosekunden seit Epoch)
pub fn NowUs(): timestamp {
  var sec: int64 := now_unix();
  return sec * 1000000;
}

// Aktuelle Zeit als Millisekunden seit Epoch
pub fn NowMs(): int64 {
  return now_unix_ms();
}

// Ende von std/time.lyx
