// std/time.lyx
// Vereinfachte Zeitfunktionen mit korrekter Lyx-Syntax

// Tage seit 1970-01-01 (Unix epoch) berechnen
pub fn days_from_civil(year: int64, month: int64, day: int64): int64 {
  var y: int64 := year;
  var m: int64 := month;
  var d: int64 := day;

  if (m <= 2) {
    y := y - 1;
    m := m + 12;
  }

  var era: int64 := y / 400;
  if (y < 0) {
    if ((y % 400) != 0) {
      era := era - 1;
    }
  }

  var yoe: int64 := y - era * 400;
  var doy: int64 := (153 * (m - 3) + 2) / 5 + d - 1;
  var doe: int64 := yoe * 365 + yoe / 4 - yoe / 100 + doy;

  return era * 146097 + doe - 719468;
}

// Jahr aus Tagen seit Epoch extrahieren
pub fn civil_year_from_days(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  return yoe + era * 400;
}

// Monat aus Tagen seit Epoch extrahieren
pub fn civil_month_from_days(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  var y: int64 := yoe + era * 400;
  var doy: int64 := doe - (365*yoe + yoe/4 - yoe/100);
  var mp: int64 := (5 * doy + 2) / 153;
  var month: int64 := mp + 3;
  if (mp >= 10) {
    month := month - 12;
  }
  return month;
}

// Tag aus Tagen seit Epoch extrahieren
pub fn civil_day_from_days(days: int64): int64 {
  var z: int64 := days + 719468;
  var era: int64 := z / 146097;
  if (z < 0) {
    if ((z % 146097) != 0) {
      era := era - 1;
    }
  }
  var doe: int64 := z - era * 146097;
  var yoe: int64 := (doe - doe/1460 + doe/36524 - doe/146096) / 365;
  var y: int64 := yoe + era * 400;
  var doy: int64 := doe - (365*yoe + yoe/4 - yoe/100);
  var mp: int64 := (5 * doy + 2) / 153;
  return doy - (153*mp+2)/5 + 1;
}

// Schaltjahr prÃ¼fen
pub fn is_leap_year(y: int64): bool {
  if ((y % 4) != 0) {
    return false;
  }
  if ((y % 100) != 0) {
    return true;
  }
  if ((y % 400) == 0) {
    return true;
  }
  return false;
}

// --- Native Zeittypen APIs ---

pub fn date_from_ymd(year: int64, month: int64, day: int64): date {
  var d: int64 := days_from_civil(year, month, day);
  return d;
}

pub fn year_from_date(d: date): int64 {
  return civil_year_from_days(d);
}

pub fn month_from_date(d: date): int64 {
  return civil_month_from_days(d);
}

pub fn day_from_date(d: date): int64 {
  return civil_day_from_days(d);
}

pub fn time_from_hms(hour: int64, minute: int64, second: int64): time {
  return hour * 3600 + minute * 60 + second;
}

pub fn hour_from_time(t: time): int64 {
  return t / 3600;
}

pub fn minute_from_time(t: time): int64 {
  return (t % 3600) / 60;
}

pub fn second_from_time(t: time): int64 {
  return t % 60;
}

pub fn datetime_from_unix_seconds(sec: int64): datetime {
  return sec;
}

pub fn datetime_to_unix_seconds(dt: datetime): int64 {
  return dt;
}

pub fn timestamp_from_unix_seconds(sec: int64): timestamp {
  return sec * 1000000;
}

pub fn unix_seconds_from_timestamp(ts: timestamp): int64 {
  return ts / 1000000;
}

// Ende von std/time.lyx
